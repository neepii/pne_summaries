
** PRAKTIKA NA EVM
** 27-11-2024

-- Аллокаторы памяти --

* Общее
Аллокатор - сущность, которая занимается выделением и освобождением памяти.
Работает с кучей
Куча - множество блоков разного размера
Блок - непрерываный кусок памяти

* Типы

** Explicit/Явный 
Програмист сам вручную выделяет и освобождает памяти
** Implicit/Неявный
Аллокатор сам берет на себе ответсвенность выделении и освобождении памяти

* Аллокаторы в stdlib.h
void *malloc(size_t size);
void free(*ptr);

Маллок также выравнивает память (обычно в posix 8 бит)
В рамках лекции размер слова будет 4 байт 

* КАК?
Аллокатор запращивает у ОС память

** map и munmap
Отображения обЪекта в физ памяти в адресное пространство 

** void *sbrk(intptr_t incr)
brk - конец кучи
Управляет размером выделенной памяти

* Требования
- Порядок выделения и освобождения должны быть произвольны
- Нельзя откладывать запрос
- Используется только куча
- Выравнивать блоки
- Нельзя манипулировать существующие блоки

* Цель
** Максимум пропускной способности
Чем быстрее, тем лучше
** Максимум утилизации памяти
Чем меньше метаинформации, тем лучше

** Баланс
Между этими двумя целями нужно найти баланс

* Фрагментация
- это плохая утилизация памяти

** Внутренняя
Выделили больше, чем нужно
** Внешняя
Есть место для памяти, но нет места для блока

* Реализация

** Линейный аллокатор
куча - массив
маллок - увеличить указатель на size
free - ничего не делать 

** Стэковый аллокатор
Линейный, но уже может очищать память (только верхние очищать, поэтому он называется стэковый)

* Термины
** Free block organization
** Placement
** Splitting
** Coalescing

* Implicit Free List
** Header
Храним размер блока, бул значение освобожден или аллоцирован
** Payload/Полезная нагрузка
Cама память
** Padding
Опционально

* Как выглядит куча
    -------\ --------------\ ------------------------------\
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   |8/0|   |16/1   |   |   |32/0   |   |   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
Каждый блок обозначает:
размер в байтах/аллоцирован или нет

* Placement
Можно установить политику размещения блоков
** first fit
Берём первый попавшийся
** next fit
Берём следующий
** best fit
Анализируем и выбираем наилучший вариант размещения(наименьший блок)
*** [!] Подумайте, какие есть минусы и плюсы каждой политики размещения. 
* Spliting
Задача разделения блока
Вдруг мы нашли блок больше, чем нужно.

* Coalescing
Объединения блоков

Это можно делать, например, пока идём по списку для нахождения нового блока

* Метод граничных маркеров

В списке мы не можем ходить назад

** Footer
Мы добавляем ещё метаинформацию в блоке, который хранит информацию о пред. блоке

* Explicit free list
Строим двусвязный список из свободных блоков

* Segregated Free Lists
Массив списков со свободными блоками с определённым размером памяти

Malloc и free за константное время ^_^
Страдаем от внутренней и внешней фрагментации

** fits
Поиск не по всей кучи
first fit приближается к best fit

* Двоичные близнецы
Хитрый аллокатор

Пусть 2^m слов в куче

** Выделение
найти доступный блок размером 2^j
если нужно, дробим пополам блоки
** Объединение
Объединяем блоки, пока не дойдём до близнеца

Страдаем от внутренней фрагментации

* Погуглите
tcmalloc
jemalloc
mimalloc

* Code from lecture
https://godbolt.org/z/6E17r1djP

* Требования к докладу

- [X] Первый блок летучек сдан
- [X] Нет просрочки 2 дэдлайнов 4 дз
- [ ]
