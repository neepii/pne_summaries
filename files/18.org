** PRAKTIKA NA EVM
** 20.11.2024

---- Системы сборки ----

* Почему не делать баш скрипты для сборки
Если изменить один файл - нужно компилить ВСЕ файлы
Если проект действительно большой, то будет занимать огромное кол-во времени
Нам нужно то, чтобы не компилить лишний раз
*Кутуев показывает автоматизацию этого процесса на Баше c помощью функций*


* Основы make
Классическая утилита сборки
Позволяет компилировать только изменённые файлы 

Основная идея - у каждого файла есть зависимость от других файлов
Если зависимость изменилась, то нужно изменить изначальный файл

Чтобы использовать, нужно сделать Makefile (файл)

https://www.gnu.org/software/make/manual/

** Синтаксис
--
<цель>: <зависимость1>, <зависимость2>, ...
	<команды оболочки/ рецепт>
--
Перечисленное является правилом (rule)
Очень важна табуляция
Makefile просто не принимает пробелы

*** Пример
--
hello: main.c
	gcc -o hello main.c
--

** PHONY
цель необязательно должна быть файлом, но если она им является, то мэйк будут принимать эту цель КАК файл

Чтобы сделать цель/цели фиктивной, нужно написать:

--
.PHONY: <цель>, <ещё одна цель>, ...
--

И тогда мейк всегда будет выполнять эту цель

PHONY - это специальное название цели

** all
Если у мейка не было аргументов, то по умолчанию он будет выполнять первую написанную цель

* Вкусные штуки make
** Важные флаги
man make ^_^

-W - запустить предпологая, что файл изменён
-n - некая откладка для мейка
** Переменные

Задаются так:
--
<название переменной> = <значение>
--

Использовать так:

--
... $(названия переменной) ...
--
Можно использовать фигурные скобки
Можно также использовать флаги, чтобы изменять переменные перед запуском
make принимает переменные окружения
*** Пример
--
CC = gcc

main.o: main.c
	$(CC) main.c -o main
--
** Автоматические переменные
 $< - это первая зависимость правила
 $@ - это имя цели правила
 $^ - это все зависимости правила

 $(RM) - команда удаления из локальной оболочки (вдруг будут собирать на виндовсе? а там ведь нет rm...)

** Встроенные функции
wildcard - найти имя файлов, удовлетворяющие паттерну( вайлдкарду )
patsubst (pattern substituion) - найти имя файлов, удовлетворяющие паттерну, и изменить по какому-то правило( replacement )
*** Паттерны
Паттерны включает в себе %

*** Пример
--
SOURCES=$(wildcard *.c)
OBJECTS=$(patsubst %.c,%.o, $(SOURCES))
--
Получаем вкусные переменные

** static pattern rule

<цели>...: <паттерн цели>: <паттерн завис.>
	<команды оболочки>

<цели> должен последовательность строк, разделённых знаков

** implicit rules
Если у правила нет рецепта, то используется рецепт по умолчанию
Для C это:
$(CC) $(CPPFLAGS) $(CFLAGS) -c

Но ломается читаемость
 
* Autotools
Утилита для сборки утилит для сборки ^_^
Делает это для того, чтобы сделать сборку программу кросс-платформенную

* Cmake
 "Компилирует" Makefile
 
cmake -S . -B build
cmake --build build

-S директория где cmakelists
-B директория билда

Генерирует файлы также для IDE

* Ninja
Тот же Makefile, но он создан для того, чтобы только генерировали
